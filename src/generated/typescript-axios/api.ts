/* tslint:disable */
/* eslint-disable */
/**
 * Tarako
 * タスク管理アプリケーションのバックエンドAPI
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface CreateDiary
 */
export interface CreateDiary {
  /**
   * 日報の日付
   * @type {string}
   * @memberof CreateDiary
   */
  date?: string;
  /**
   * 日報の詳細
   * @type {string}
   * @memberof CreateDiary
   */
  message?: string;
}
/**
 *
 * @export
 * @interface DiaryBase
 */
export interface DiaryBase {
  /**
   * 日報ID
   * @type {string}
   * @memberof DiaryBase
   */
  diary_id?: string;
  /**
   * 課ID
   * @type {number}
   * @memberof DiaryBase
   */
  section_id?: number;
  /**
   * 日報の日付
   * @type {string}
   * @memberof DiaryBase
   */
  date?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof DiaryBase
   */
  details?: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof DiaryBase
   */
  serious?: number;
  /**
   * 作成日時
   * @type {string}
   * @memberof DiaryBase
   */
  created_at?: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof DiaryBase
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface PostTask201Response
 */
export interface PostTask201Response {
  /**
   *
   * @type {Task}
   * @memberof PostTask201Response
   */
  task?: Task;
  /**
   * タスクの作成を通知する
   * @type {string}
   * @memberof PostTask201Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface PostTask208Response
 */
export interface PostTask208Response {
  /**
   *
   * @type {Task}
   * @memberof PostTask208Response
   */
  originTask?: Task;
  /**
   *
   * @type {Task}
   * @memberof PostTask208Response
   */
  updatedTask?: Task;
  /**
   * 提案の理由
   * @type {string}
   * @memberof PostTask208Response
   */
  message?: string;
}
/**
 * 進捗状況
 * @export
 * @interface ProgressItem
 */
export interface ProgressItem {
  /**
   *
   * @type {string}
   * @memberof ProgressItem
   */
  datetime?: string;
  /**
   * 進捗率
   * @type {number}
   * @memberof ProgressItem
   */
  percentage?: number;
}
/**
 *
 * @export
 * @interface RequestTaskAndFile
 */
export interface RequestTaskAndFile {
  /**
   * ユーザーID
   * @type {string}
   * @memberof RequestTaskAndFile
   */
  user_id?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof RequestTaskAndFile
   */
  text?: string;
  /**
   * タスクで作成したファイル
   * @type {File}
   * @memberof RequestTaskAndFile
   */
  file?: File;
}
/**
 *
 * @export
 * @interface RequestTextFileTask
 */
export interface RequestTextFileTask {
  /**
   * タスクの詳細
   * @type {string}
   * @memberof RequestTextFileTask
   */
  task?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof RequestTextFileTask
   */
  text?: string;
  /**
   * タスクで作成したファイル
   * @type {File}
   * @memberof RequestTextFileTask
   */
  file?: File;
}
/**
 *
 * @export
 * @interface Section
 */
export interface Section {
  /**
   * 課ID
   * @type {number}
   * @memberof Section
   */
  section_id?: number;
  /**
   * 課名
   * @type {string}
   * @memberof Section
   */
  name?: string;
  /**
   * 課のアイコン名
   * @type {string}
   * @memberof Section
   */
  icon?: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof Section
   */
  created_at?: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof Section
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface SectionDiary
 */
export interface SectionDiary {
  /**
   *
   * @type {Section}
   * @memberof SectionDiary
   */
  section?: Section;
  /**
   * 日報の作成に用いられたユーザーのIDリスト
   * @type {Array<string>}
   * @memberof SectionDiary
   */
  user_ids?: Array<string>;
  /**
   * 日報ID
   * @type {string}
   * @memberof SectionDiary
   */
  diary_id?: string;
  /**
   * 課ID
   * @type {number}
   * @memberof SectionDiary
   */
  section_id?: number;
  /**
   * 日報の日付
   * @type {string}
   * @memberof SectionDiary
   */
  date?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof SectionDiary
   */
  details?: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof SectionDiary
   */
  serious?: number;
  /**
   * 作成日時
   * @type {string}
   * @memberof SectionDiary
   */
  created_at?: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof SectionDiary
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * タスクID
   * @type {string}
   * @memberof Task
   */
  task_id?: string;
  /**
   * ユーザーID
   * @type {string}
   * @memberof Task
   */
  assigned_to?: string | null;
  /**
   * 課ID
   * @type {number}
   * @memberof Task
   */
  section_id?: number;
  /**
   * タスク名
   * @type {string}
   * @memberof Task
   */
  title?: string;
  /**
   *
   * @type {TaskCategory}
   * @memberof Task
   */
  category?: TaskCategory;
  /**
   * タスクのタグリスト
   * @type {Array<string>}
   * @memberof Task
   */
  tags?: Array<string>;
  /**
   * 進捗状況リスト
   * @type {Array<ProgressItem>}
   * @memberof Task
   */
  progresses?: Array<ProgressItem>;
  /**
   * タスクが完了したかどうか。progressesから自動的に判定される。検索の高速化のために存在
   * @type {boolean}
   * @memberof Task
   */
  completed?: boolean;
  /**
   * 深刻度
   * @type {number}
   * @memberof Task
   */
  serious?: number;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof Task
   */
  details?: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof Task
   */
  created_at?: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof Task
   */
  updated_at?: string;
}

/**
 * タスクのカテゴリー
 * @export
 * @enum {string}
 */

export const TaskCategory = {
  Hr: 'HR',
  Accounting: 'Accounting',
  GeneralAffairs: 'GeneralAffairs',
  Diary: 'Diary',
  Other: 'Other',
} as const;

export type TaskCategory = (typeof TaskCategory)[keyof typeof TaskCategory];

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   * 課ID
   * @type {number}
   * @memberof User
   */
  section_id?: number;
  /**
   * ユーザーID
   * @type {string}
   * @memberof User
   */
  user_id?: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof User
   */
  created_at?: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof User
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface UserDiary
 */
export interface UserDiary {
  /**
   * ユーザーID
   * @type {string}
   * @memberof UserDiary
   */
  user_id?: string;
  /**
   * 日報の作成に用いられたタスクのIDリスト
   * @type {Array<string>}
   * @memberof UserDiary
   */
  task_ids?: Array<string>;
  /**
   * 日報ID
   * @type {string}
   * @memberof UserDiary
   */
  diary_id?: string;
  /**
   * 課ID
   * @type {number}
   * @memberof UserDiary
   */
  section_id?: number;
  /**
   * 日報の日付
   * @type {string}
   * @memberof UserDiary
   */
  date?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof UserDiary
   */
  details?: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof UserDiary
   */
  serious?: number;
  /**
   * 作成日時
   * @type {string}
   * @memberof UserDiary
   */
  created_at?: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof UserDiary
   */
  updated_at?: string;
}

/**
 * SectionApi - axios parameter creator
 * @export
 */
export const SectionApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 課の詳細
     * @param {number} sectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionEntry: async (
      sectionId: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('getSectionEntry', 'sectionId', sectionId);
      const localVarPath = `/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSections: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の作成
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionEntry: async (
      section: Section,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'section' is not null or undefined
      assertParamExists('postSectionEntry', 'section', section);
      const localVarPath = `/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        section,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の更新
     * @param {number} sectionId
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionEntry: async (
      sectionId: number,
      section: Section,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('putSectionEntry', 'sectionId', sectionId);
      // verify required parameter 'section' is not null or undefined
      assertParamExists('putSectionEntry', 'section', section);
      const localVarPath = `/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        section,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SectionApi - functional programming interface
 * @export
 */
export const SectionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SectionApiAxiosParamCreator(configuration);
  return {
    /**
     * 課の詳細
     * @param {number} sectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSectionEntry(
      sectionId: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionEntry(
        sectionId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSections(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Section>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSections(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の作成
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSectionEntry(
      section: Section,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postSectionEntry(section, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の更新
     * @param {number} sectionId
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putSectionEntry(
      sectionId: number,
      section: Section,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putSectionEntry(
        sectionId,
        section,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SectionApi - factory interface
 * @export
 */
export const SectionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SectionApiFp(configuration);
  return {
    /**
     * 課の詳細
     * @param {number} sectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionEntry(sectionId: number, options?: any): AxiosPromise<Section> {
      return localVarFp
        .getSectionEntry(sectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSections(options?: any): AxiosPromise<Array<Section>> {
      return localVarFp
        .getSections(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の作成
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionEntry(section: Section, options?: any): AxiosPromise<Section> {
      return localVarFp
        .postSectionEntry(section, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の更新
     * @param {number} sectionId
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionEntry(
      sectionId: number,
      section: Section,
      options?: any,
    ): AxiosPromise<Section> {
      return localVarFp
        .putSectionEntry(sectionId, section, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SectionApi - object-oriented interface
 * @export
 * @class SectionApi
 * @extends {BaseAPI}
 */
export class SectionApi extends BaseAPI {
  /**
   * 課の詳細
   * @param {number} sectionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public getSectionEntry(sectionId: number, options?: AxiosRequestConfig) {
    return SectionApiFp(this.configuration)
      .getSectionEntry(sectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の一覧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public getSections(options?: AxiosRequestConfig) {
    return SectionApiFp(this.configuration)
      .getSections(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の作成
   * @param {Section} section
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public postSectionEntry(section: Section, options?: AxiosRequestConfig) {
    return SectionApiFp(this.configuration)
      .postSectionEntry(section, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の更新
   * @param {number} sectionId
   * @param {Section} section
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public putSectionEntry(
    sectionId: number,
    section: Section,
    options?: AxiosRequestConfig,
  ) {
    return SectionApiFp(this.configuration)
      .putSectionEntry(sectionId, section, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SectionDiaryApi - axios parameter creator
 * @export
 */
export const SectionDiaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 日報の削除
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSectionDiaryEntry: async (
      sectionId: number,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('deleteSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('deleteSectionDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSectionsDiaries: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/diary/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の日報一覧
     * @param {number} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaries: async (
      sectionId: number,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('getSectionDiaries', 'sectionId', sectionId);
      const localVarPath = `/diary/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報詳細
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaryEntry: async (
      sectionId: number,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('getSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('getSectionDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {number} sectionId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionDiaryEntry: async (
      sectionId: number,
      createDiary: CreateDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('postSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'createDiary' is not null or undefined
      assertParamExists('postSectionDiaryEntry', 'createDiary', createDiary);
      const localVarPath = `/diary/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の更新
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionDiaryEntry: async (
      sectionId: number,
      diaryId: string,
      sectionDiary: SectionDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('putSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('putSectionDiaryEntry', 'diaryId', diaryId);
      // verify required parameter 'sectionDiary' is not null or undefined
      assertParamExists('putSectionDiaryEntry', 'sectionDiary', sectionDiary);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sectionDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SectionDiaryApi - functional programming interface
 * @export
 */
export const SectionDiaryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SectionDiaryApiAxiosParamCreator(configuration);
  return {
    /**
     * 日報の削除
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSectionDiaryEntry(
          sectionId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllSectionsDiaries(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SectionDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllSectionsDiaries(
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の日報一覧
     * @param {number} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSectionDiaries(
      sectionId: number,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SectionDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSectionDiaries(
          sectionId,
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報詳細
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSectionDiaryEntry(
          sectionId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {number} sectionId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSectionDiaryEntry(
      sectionId: number,
      createDiary: CreateDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postSectionDiaryEntry(
          sectionId,
          createDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の更新
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      sectionDiary: SectionDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putSectionDiaryEntry(
          sectionId,
          diaryId,
          sectionDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SectionDiaryApi - factory interface
 * @export
 */
export const SectionDiaryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SectionDiaryApiFp(configuration);
  return {
    /**
     * 日報の削除
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSectionDiaryEntry(sectionId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSectionsDiaries(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<SectionDiary>> {
      return localVarFp
        .getAllSectionsDiaries(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の日報一覧
     * @param {number} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaries(
      sectionId: number,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<SectionDiary>> {
      return localVarFp
        .getSectionDiaries(sectionId, from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報詳細
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .getSectionDiaryEntry(sectionId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {number} sectionId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionDiaryEntry(
      sectionId: number,
      createDiary: CreateDiary,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .postSectionDiaryEntry(sectionId, createDiary, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の更新
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      sectionDiary: SectionDiary,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .putSectionDiaryEntry(sectionId, diaryId, sectionDiary, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SectionDiaryApi - object-oriented interface
 * @export
 * @class SectionDiaryApi
 * @extends {BaseAPI}
 */
export class SectionDiaryApi extends BaseAPI {
  /**
   * 日報の削除
   * @param {number} sectionId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public deleteSectionDiaryEntry(
    sectionId: number,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .deleteSectionDiaryEntry(sectionId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 全課の日報一覧
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public getAllSectionsDiaries(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .getAllSectionsDiaries(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の日報一覧
   * @param {number} sectionId
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public getSectionDiaries(
    sectionId: number,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .getSectionDiaries(sectionId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報詳細
   * @param {number} sectionId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public getSectionDiaryEntry(
    sectionId: number,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .getSectionDiaryEntry(sectionId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課に所属しているユーザーの日報から、課の日報を作成
   * @param {number} sectionId
   * @param {CreateDiary} createDiary 日報の作成
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public postSectionDiaryEntry(
    sectionId: number,
    createDiary: CreateDiary,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .postSectionDiaryEntry(sectionId, createDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の更新
   * @param {number} sectionId
   * @param {string} diaryId
   * @param {SectionDiary} sectionDiary 日報の更新
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public putSectionDiaryEntry(
    sectionId: number,
    diaryId: string,
    sectionDiary: SectionDiary,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .putSectionDiaryEntry(sectionId, diaryId, sectionDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskEntry: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('deleteTaskEntry', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskEntry: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskEntry', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
     * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
     * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks: async (
      notAssigned?: boolean,
      userId?: Array<string>,
      from?: string,
      to?: string,
      status?: GetTasksStatusEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (notAssigned !== undefined) {
        localVarQueryParameter['not_assigned'] = notAssigned;
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (from !== undefined) {
        localVarQueryParameter['from'] = from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクの投稿
     * @param {RequestTaskAndFile} requestTaskAndFile
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTask: async (
      requestTaskAndFile: RequestTaskAndFile,
      forceCreate?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestTaskAndFile' is not null or undefined
      assertParamExists('postTask', 'requestTaskAndFile', requestTaskAndFile);
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (forceCreate !== undefined) {
        localVarQueryParameter['force_create'] = forceCreate;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestTaskAndFile,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {RequestTextFileTask} requestTextFileTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTaskEntry: async (
      taskId: string,
      requestTextFileTask: RequestTextFileTask,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('putTaskEntry', 'taskId', taskId);
      // verify required parameter 'requestTextFileTask' is not null or undefined
      assertParamExists(
        'putTaskEntry',
        'requestTextFileTask',
        requestTextFileTask,
      );
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestTextFileTask,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration);
  return {
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTaskEntry(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskEntry(
        taskId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskEntry(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskEntry(
        taskId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
     * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
     * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasks(
      notAssigned?: boolean,
      userId?: Array<string>,
      from?: string,
      to?: string,
      status?: GetTasksStatusEnum,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(
        notAssigned,
        userId,
        from,
        to,
        status,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクの投稿
     * @param {RequestTaskAndFile} requestTaskAndFile
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTask(
      requestTaskAndFile: RequestTaskAndFile,
      forceCreate?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PostTask201Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postTask(
        requestTaskAndFile,
        forceCreate,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {RequestTextFileTask} requestTextFileTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putTaskEntry(
      taskId: string,
      requestTextFileTask: RequestTextFileTask,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskEntry(
        taskId,
        requestTextFileTask,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TaskApiFp(configuration);
  return {
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskEntry(taskId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteTaskEntry(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskEntry(taskId: string, options?: any): AxiosPromise<Task> {
      return localVarFp
        .getTaskEntry(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
     * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
     * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks(
      notAssigned?: boolean,
      userId?: Array<string>,
      from?: string,
      to?: string,
      status?: GetTasksStatusEnum,
      options?: any,
    ): AxiosPromise<Array<Task>> {
      return localVarFp
        .getTasks(notAssigned, userId, from, to, status, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクの投稿
     * @param {RequestTaskAndFile} requestTaskAndFile
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTask(
      requestTaskAndFile: RequestTaskAndFile,
      forceCreate?: boolean,
      options?: any,
    ): AxiosPromise<PostTask201Response> {
      return localVarFp
        .postTask(requestTaskAndFile, forceCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {RequestTextFileTask} requestTextFileTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTaskEntry(
      taskId: string,
      requestTextFileTask: RequestTextFileTask,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .putTaskEntry(taskId, requestTextFileTask, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
  /**
   * タスクの削除
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public deleteTaskEntry(taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .deleteTaskEntry(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスク詳細の取得
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTaskEntry(taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .getTaskEntry(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
   * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
   * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
   * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTasks(
    notAssigned?: boolean,
    userId?: Array<string>,
    from?: string,
    to?: string,
    status?: GetTasksStatusEnum,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .getTasks(notAssigned, userId, from, to, status, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクの投稿
   * @param {RequestTaskAndFile} requestTaskAndFile
   * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public postTask(
    requestTaskAndFile: RequestTaskAndFile,
    forceCreate?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .postTask(requestTaskAndFile, forceCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクを更新する。
   * @param {string} taskId
   * @param {RequestTextFileTask} requestTextFileTask
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public putTaskEntry(
    taskId: string,
    requestTextFileTask: RequestTextFileTask,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .putTaskEntry(taskId, requestTextFileTask, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetTasksStatusEnum = {
  InProgress: 'in_progress',
  Completed: 'completed',
} as const;
export type GetTasksStatusEnum =
  (typeof GetTasksStatusEnum)[keyof typeof GetTasksStatusEnum];

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserEntry: async (
      userId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserEntry', 'userId', userId);
      const localVarPath = `/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [sectionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      sectionId?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sectionId !== undefined) {
        localVarQueryParameter['section_id'] = sectionId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの作成
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEntry: async (
      user: User,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      assertParamExists('postUserEntry', 'user', user);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの更新
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserEntry: async (
      userId: string,
      user: User,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('putUserEntry', 'userId', userId);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('putUserEntry', 'user', user);
      const localVarPath = `/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserEntry(
      userId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEntry(
        userId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {number} [sectionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      sectionId?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        sectionId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの作成
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserEntry(
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postUserEntry(
        user,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの更新
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserEntry(
      userId: string,
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putUserEntry(
        userId,
        user,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserEntry(userId: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserEntry(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} [sectionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(sectionId?: number, options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(sectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの作成
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEntry(user: User, options?: any): AxiosPromise<User> {
      return localVarFp
        .postUserEntry(user, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの更新
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserEntry(
      userId: string,
      user: User,
      options?: any,
    ): AxiosPromise<User> {
      return localVarFp
        .putUserEntry(userId, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * ユーザー詳細の取得
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserEntry(userId: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserEntry(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [sectionId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUsers(sectionId?: number, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUsers(sectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの作成
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public postUserEntry(user: User, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .postUserEntry(user, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの更新
   * @param {string} userId
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public putUserEntry(
    userId: string,
    user: User,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .putUserEntry(userId, user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserDiaryApi - axios parameter creator
 * @export
 */
export const UserDiaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserDiaryEntry: async (
      userId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('deleteUserDiaryEntry', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('deleteUserDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersDiaries: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/diary/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaries: async (
      userId: string,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserDiaries', 'userId', userId);
      const localVarPath = `/diary/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaryEntry: async (
      userId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserDiaryEntry', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('getUserDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDiaryEntry: async (
      userId: string,
      createDiary: CreateDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('postUserDiaryEntry', 'userId', userId);
      // verify required parameter 'createDiary' is not null or undefined
      assertParamExists('postUserDiaryEntry', 'createDiary', createDiary);
      const localVarPath = `/diary/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserDiaryEntry: async (
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('putUserDiaryEntry', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('putUserDiaryEntry', 'diaryId', diaryId);
      // verify required parameter 'userDiary' is not null or undefined
      assertParamExists('putUserDiaryEntry', 'userDiary', userDiary);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserDiaryApi - functional programming interface
 * @export
 */
export const UserDiaryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserDiaryApiAxiosParamCreator(configuration);
  return {
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserDiaryEntry(
          userId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUsersDiaries(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllUsersDiaries(from, to, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserDiaries(
      userId: string,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserDiary>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDiaries(
        userId,
        from,
        to,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserDiaryEntry(
          userId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserDiaryEntry(
      userId: string,
      createDiary: CreateDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUserDiaryEntry(
          userId,
          createDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserDiaryEntry(
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putUserDiaryEntry(
          userId,
          diaryId,
          userDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserDiaryApi - factory interface
 * @export
 */
export const UserDiaryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserDiaryApiFp(configuration);
  return {
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserDiaryEntry(userId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersDiaries(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<UserDiary>> {
      return localVarFp
        .getAllUsersDiaries(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaries(
      userId: string,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<UserDiary>> {
      return localVarFp
        .getUserDiaries(userId, from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .getUserDiaryEntry(userId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDiaryEntry(
      userId: string,
      createDiary: CreateDiary,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .postUserDiaryEntry(userId, createDiary, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserDiaryEntry(
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .putUserDiaryEntry(userId, diaryId, userDiary, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserDiaryApi - object-oriented interface
 * @export
 * @class UserDiaryApi
 * @extends {BaseAPI}
 */
export class UserDiaryApi extends BaseAPI {
  /**
   * 日報の削除
   * @param {string} userId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public deleteUserDiaryEntry(
    userId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .deleteUserDiaryEntry(userId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 全員の日報一覧
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public getAllUsersDiaries(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .getAllUsersDiaries(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの日報一覧
   * @param {string} userId
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public getUserDiaries(
    userId: string,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .getUserDiaries(userId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報詳細
   * @param {string} userId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public getUserDiaryEntry(
    userId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .getUserDiaryEntry(userId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報を作成
   * @param {string} userId
   * @param {CreateDiary} createDiary 日報の作成
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public postUserDiaryEntry(
    userId: string,
    createDiary: CreateDiary,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .postUserDiaryEntry(userId, createDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の更新
   * @param {string} userId
   * @param {string} diaryId
   * @param {UserDiary} userDiary 日報の更新
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public putUserDiaryEntry(
    userId: string,
    diaryId: string,
    userDiary: UserDiary,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .putUserDiaryEntry(userId, diaryId, userDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
