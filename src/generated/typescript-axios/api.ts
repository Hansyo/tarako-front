/* tslint:disable */
/* eslint-disable */
/**
 * Tarako
 * タスク管理アプリケーションのバックエンドAPI
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface CreateDiary
 */
export interface CreateDiary {
  /**
   * 日報の日付
   * @type {string}
   * @memberof CreateDiary
   */
  date?: string;
}
/**
 *
 * @export
 * @interface DiaryBase
 */
export interface DiaryBase {
  /**
   * 日報ID
   * @type {string}
   * @memberof DiaryBase
   */
  diary_id?: string;
  /**
   * 日報の日付
   * @type {string}
   * @memberof DiaryBase
   */
  date?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof DiaryBase
   */
  details?: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof DiaryBase
   */
  serious?: number;
  /**
   * 日報の作成に用いられたタスクのIDリスト
   * @type {Array<string>}
   * @memberof DiaryBase
   */
  task_ids?: Array<string>;
  /**
   * 作成日時
   * @type {any}
   * @memberof DiaryBase
   */
  created_at?: any;
  /**
   * 更新日時
   * @type {string}
   * @memberof DiaryBase
   */
  updated_at?: string;
}
/**
 * 進捗状況
 * @export
 * @interface ProgressItem
 */
export interface ProgressItem {
  /**
   *
   * @type {string}
   * @memberof ProgressItem
   */
  datetime?: string;
  /**
   * 進捗率
   * @type {number}
   * @memberof ProgressItem
   */
  percentage?: number;
}
/**
 *
 * @export
 * @interface RequestTaskAndFile
 */
export interface RequestTaskAndFile {
  /**
   * タスクの詳細
   * @type {string}
   * @memberof RequestTaskAndFile
   */
  text?: string;
  /**
   * タスクで作成したファイル
   * @type {File}
   * @memberof RequestTaskAndFile
   */
  file?: File;
}
/**
 *
 * @export
 * @interface Section
 */
export interface Section {
  /**
   * 課ID
   * @type {number}
   * @memberof Section
   */
  section_id?: number;
  /**
   * 課名
   * @type {string}
   * @memberof Section
   */
  name?: string;
  /**
   * 作成日時
   * @type {any}
   * @memberof Section
   */
  created_at?: any;
  /**
   * 更新日時
   * @type {string}
   * @memberof Section
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface SectionDiary
 */
export interface SectionDiary {
  /**
   *
   * @type {Section}
   * @memberof SectionDiary
   */
  section?: Section;
  /**
   * 日報ID
   * @type {string}
   * @memberof SectionDiary
   */
  diary_id?: string;
  /**
   * 日報の日付
   * @type {string}
   * @memberof SectionDiary
   */
  date?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof SectionDiary
   */
  details?: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof SectionDiary
   */
  serious?: number;
  /**
   * 日報の作成に用いられたタスクのIDリスト
   * @type {Array<string>}
   * @memberof SectionDiary
   */
  task_ids?: Array<string>;
  /**
   * 作成日時
   * @type {any}
   * @memberof SectionDiary
   */
  created_at?: any;
  /**
   * 更新日時
   * @type {string}
   * @memberof SectionDiary
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * タスクID
   * @type {string}
   * @memberof Task
   */
  task_id?: string;
  /**
   * ユーザーID
   * @type {string}
   * @memberof Task
   */
  assigned_by?: string | null;
  /**
   * タスク名
   * @type {string}
   * @memberof Task
   */
  title?: string;
  /**
   *
   * @type {TaskCategory}
   * @memberof Task
   */
  category?: TaskCategory;
  /**
   * タスクのタグリスト
   * @type {Array<string>}
   * @memberof Task
   */
  tags?: Array<string>;
  /**
   * 進捗状況リスト
   * @type {Array<ProgressItem>}
   * @memberof Task
   */
  progresses?: Array<ProgressItem>;
  /**
   * タスクが完了したかどうか。progressesから自動的に判定される。検索の高速化のために存在
   * @type {boolean}
   * @memberof Task
   */
  completed?: boolean;
  /**
   * 深刻度
   * @type {number}
   * @memberof Task
   */
  serious?: number;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof Task
   */
  details?: string;
  /**
   * 作成日時
   * @type {any}
   * @memberof Task
   */
  created_at?: any;
  /**
   * 更新日時
   * @type {string}
   * @memberof Task
   */
  updated_at?: string;
}

/**
 * タスクのカテゴリー
 * @export
 * @enum {string}
 */

export const TaskCategory = {
  Hr: 'HR',
  Accounting: 'Accounting',
  GeneralAffairs: 'GeneralAffairs',
  Diary: 'Diary',
  Other: 'Other',
} as const;

export type TaskCategory = (typeof TaskCategory)[keyof typeof TaskCategory];

/**
 *
 * @export
 * @interface TasksPost208Response
 */
export interface TasksPost208Response {
  /**
   *
   * @type {Task}
   * @memberof TasksPost208Response
   */
  Task?: Task;
  /**
   * 提案の理由
   * @type {string}
   * @memberof TasksPost208Response
   */
  message?: string;
}
/**
 * @type TasksPostRequest
 * @export
 */
export type TasksPostRequest = File | RequestTaskAndFile | string;

/**
 * @type TasksTaskIdPutRequest
 * @export
 */
export type TasksTaskIdPutRequest = File | RequestTaskAndFile | Task | string;

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * ユーザーID
   * @type {string}
   * @memberof User
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   * 部署名
   * @type {string}
   * @memberof User
   */
  department?: string;
  /**
   *
   * @type {Section}
   * @memberof User
   */
  section?: Section;
  /**
   * 作成日時
   * @type {any}
   * @memberof User
   */
  created_at?: any;
  /**
   * 更新日時
   * @type {string}
   * @memberof User
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface UserDiary
 */
export interface UserDiary {
  /**
   * ユーザーID
   * @type {string}
   * @memberof UserDiary
   */
  user_id?: string;
  /**
   * 日報ID
   * @type {string}
   * @memberof UserDiary
   */
  diary_id?: string;
  /**
   * 日報の日付
   * @type {string}
   * @memberof UserDiary
   */
  date?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof UserDiary
   */
  details?: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof UserDiary
   */
  serious?: number;
  /**
   * 日報の作成に用いられたタスクのIDリスト
   * @type {Array<string>}
   * @memberof UserDiary
   */
  task_ids?: Array<string>;
  /**
   * 作成日時
   * @type {any}
   * @memberof UserDiary
   */
  created_at?: any;
  /**
   * 更新日時
   * @type {string}
   * @memberof UserDiary
   */
  updated_at?: string;
}

/**
 * SectionDiaryApi - axios parameter creator
 * @export
 */
export const SectionDiaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsGet: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/diary/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の削除
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdDiaryIdDelete: async (
      sectionId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists(
        'diarySectionsSectionIdDiaryIdDelete',
        'sectionId',
        sectionId,
      );
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists(
        'diarySectionsSectionIdDiaryIdDelete',
        'diaryId',
        diaryId,
      );
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報詳細
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdDiaryIdGet: async (
      sectionId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists(
        'diarySectionsSectionIdDiaryIdGet',
        'sectionId',
        sectionId,
      );
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('diarySectionsSectionIdDiaryIdGet', 'diaryId', diaryId);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の更新
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdDiaryIdPut: async (
      sectionId: string,
      diaryId: string,
      sectionDiary: SectionDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists(
        'diarySectionsSectionIdDiaryIdPut',
        'sectionId',
        sectionId,
      );
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('diarySectionsSectionIdDiaryIdPut', 'diaryId', diaryId);
      // verify required parameter 'sectionDiary' is not null or undefined
      assertParamExists(
        'diarySectionsSectionIdDiaryIdPut',
        'sectionDiary',
        sectionDiary,
      );
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sectionDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdGet: async (
      sectionId: string,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('diarySectionsSectionIdGet', 'sectionId', sectionId);
      const localVarPath = `/diary/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {string} sectionId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdPost: async (
      sectionId: string,
      createDiary: CreateDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('diarySectionsSectionIdPost', 'sectionId', sectionId);
      // verify required parameter 'createDiary' is not null or undefined
      assertParamExists(
        'diarySectionsSectionIdPost',
        'createDiary',
        createDiary,
      );
      const localVarPath = `/diary/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SectionDiaryApi - functional programming interface
 * @export
 */
export const SectionDiaryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SectionDiaryApiAxiosParamCreator(configuration);
  return {
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diarySectionsGet(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SectionDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diarySectionsGet(from, to, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の削除
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diarySectionsSectionIdDiaryIdDelete(
      sectionId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diarySectionsSectionIdDiaryIdDelete(
          sectionId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報詳細
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diarySectionsSectionIdDiaryIdGet(
      sectionId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diarySectionsSectionIdDiaryIdGet(
          sectionId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の更新
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diarySectionsSectionIdDiaryIdPut(
      sectionId: string,
      diaryId: string,
      sectionDiary: SectionDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diarySectionsSectionIdDiaryIdPut(
          sectionId,
          diaryId,
          sectionDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diarySectionsSectionIdGet(
      sectionId: string,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SectionDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diarySectionsSectionIdGet(
          sectionId,
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {string} sectionId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diarySectionsSectionIdPost(
      sectionId: string,
      createDiary: CreateDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diarySectionsSectionIdPost(
          sectionId,
          createDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SectionDiaryApi - factory interface
 * @export
 */
export const SectionDiaryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SectionDiaryApiFp(configuration);
  return {
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsGet(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<SectionDiary>> {
      return localVarFp
        .diarySectionsGet(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の削除
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdDiaryIdDelete(
      sectionId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .diarySectionsSectionIdDiaryIdDelete(sectionId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報詳細
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdDiaryIdGet(
      sectionId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .diarySectionsSectionIdDiaryIdGet(sectionId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の更新
     * @param {string} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdDiaryIdPut(
      sectionId: string,
      diaryId: string,
      sectionDiary: SectionDiary,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .diarySectionsSectionIdDiaryIdPut(
          sectionId,
          diaryId,
          sectionDiary,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdGet(
      sectionId: string,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<SectionDiary>> {
      return localVarFp
        .diarySectionsSectionIdGet(sectionId, from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {string} sectionId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diarySectionsSectionIdPost(
      sectionId: string,
      createDiary: CreateDiary,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .diarySectionsSectionIdPost(sectionId, createDiary, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SectionDiaryApi - object-oriented interface
 * @export
 * @class SectionDiaryApi
 * @extends {BaseAPI}
 */
export class SectionDiaryApi extends BaseAPI {
  /**
   * 全課の日報一覧
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public diarySectionsGet(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .diarySectionsGet(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の削除
   * @param {string} sectionId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public diarySectionsSectionIdDiaryIdDelete(
    sectionId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .diarySectionsSectionIdDiaryIdDelete(sectionId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報詳細
   * @param {string} sectionId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public diarySectionsSectionIdDiaryIdGet(
    sectionId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .diarySectionsSectionIdDiaryIdGet(sectionId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の更新
   * @param {string} sectionId
   * @param {string} diaryId
   * @param {SectionDiary} sectionDiary 日報の更新
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public diarySectionsSectionIdDiaryIdPut(
    sectionId: string,
    diaryId: string,
    sectionDiary: SectionDiary,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .diarySectionsSectionIdDiaryIdPut(
        sectionId,
        diaryId,
        sectionDiary,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} sectionId
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public diarySectionsSectionIdGet(
    sectionId: string,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .diarySectionsSectionIdGet(sectionId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課に所属しているユーザーの日報から、課の日報を作成
   * @param {string} sectionId
   * @param {CreateDiary} createDiary 日報の作成
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public diarySectionsSectionIdPost(
    sectionId: string,
    createDiary: CreateDiary,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .diarySectionsSectionIdPost(sectionId, createDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {string} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される
     * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
     * @param {TasksGetStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet: async (
      notAssigned?: boolean,
      userId?: string,
      from?: string,
      to?: string,
      status?: TasksGetStatusEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (notAssigned !== undefined) {
        localVarQueryParameter['not_assigned'] = notAssigned;
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (from !== undefined) {
        localVarQueryParameter['from'] = from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクの投稿
     * @param {TasksPostRequest} tasksPostRequest
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksPost: async (
      tasksPostRequest: TasksPostRequest,
      forceCreate?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tasksPostRequest' is not null or undefined
      assertParamExists('tasksPost', 'tasksPostRequest', tasksPostRequest);
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (forceCreate !== undefined) {
        localVarQueryParameter['force_create'] = forceCreate;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tasksPostRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdDelete: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('tasksTaskIdDelete', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdGet: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('tasksTaskIdGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {TasksTaskIdPutRequest} tasksTaskIdPutRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdPut: async (
      taskId: string,
      tasksTaskIdPutRequest: TasksTaskIdPutRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('tasksTaskIdPut', 'taskId', taskId);
      // verify required parameter 'tasksTaskIdPutRequest' is not null or undefined
      assertParamExists(
        'tasksTaskIdPut',
        'tasksTaskIdPutRequest',
        tasksTaskIdPutRequest,
      );
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tasksTaskIdPutRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {string} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される
     * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
     * @param {TasksGetStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tasksGet(
      notAssigned?: boolean,
      userId?: string,
      from?: string,
      to?: string,
      status?: TasksGetStatusEnum,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tasksGet(
        notAssigned,
        userId,
        from,
        to,
        status,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクの投稿
     * @param {TasksPostRequest} tasksPostRequest
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tasksPost(
      tasksPostRequest: TasksPostRequest,
      forceCreate?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPost(
        tasksPostRequest,
        forceCreate,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tasksTaskIdDelete(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tasksTaskIdDelete(taskId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tasksTaskIdGet(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tasksTaskIdGet(
        taskId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {TasksTaskIdPutRequest} tasksTaskIdPutRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tasksTaskIdPut(
      taskId: string,
      tasksTaskIdPutRequest: TasksTaskIdPutRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tasksTaskIdPut(
        taskId,
        tasksTaskIdPutRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TaskApiFp(configuration);
  return {
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {string} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される
     * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
     * @param {TasksGetStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet(
      notAssigned?: boolean,
      userId?: string,
      from?: string,
      to?: string,
      status?: TasksGetStatusEnum,
      options?: any,
    ): AxiosPromise<Array<Task>> {
      return localVarFp
        .tasksGet(notAssigned, userId, from, to, status, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクの投稿
     * @param {TasksPostRequest} tasksPostRequest
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksPost(
      tasksPostRequest: TasksPostRequest,
      forceCreate?: boolean,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tasksPost(tasksPostRequest, forceCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdDelete(taskId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .tasksTaskIdDelete(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdGet(taskId: string, options?: any): AxiosPromise<Task> {
      return localVarFp
        .tasksTaskIdGet(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {TasksTaskIdPutRequest} tasksTaskIdPutRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdPut(
      taskId: string,
      tasksTaskIdPutRequest: TasksTaskIdPutRequest,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tasksTaskIdPut(taskId, tasksTaskIdPutRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
  /**
   *
   * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
   * @param {string} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される
   * @param {string} [from] タスクの開始期間で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] タスクの終了期間で絞り込み。指定しなかった場合、制限なし
   * @param {TasksGetStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public tasksGet(
    notAssigned?: boolean,
    userId?: string,
    from?: string,
    to?: string,
    status?: TasksGetStatusEnum,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .tasksGet(notAssigned, userId, from, to, status, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクの投稿
   * @param {TasksPostRequest} tasksPostRequest
   * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public tasksPost(
    tasksPostRequest: TasksPostRequest,
    forceCreate?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .tasksPost(tasksPostRequest, forceCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクの削除
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public tasksTaskIdDelete(taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .tasksTaskIdDelete(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスク詳細の取得
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public tasksTaskIdGet(taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .tasksTaskIdGet(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクを更新する。
   * @param {string} taskId
   * @param {TasksTaskIdPutRequest} tasksTaskIdPutRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public tasksTaskIdPut(
    taskId: string,
    tasksTaskIdPutRequest: TasksTaskIdPutRequest,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .tasksTaskIdPut(taskId, tasksTaskIdPutRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const TasksGetStatusEnum = {
  InProgress: 'in_progress',
  Completed: 'completed',
} as const;
export type TasksGetStatusEnum =
  (typeof TasksGetStatusEnum)[keyof typeof TasksGetStatusEnum];

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} [department] 部署絞り込み。指定しなかった場合、すべての部署
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet: async (
      department?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (department !== undefined) {
        localVarQueryParameter['department'] = department;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUserIdGet: async (
      userId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersUserIdGet', 'userId', userId);
      const localVarPath = `/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザー情報の更新。管理者を除き、自分の情報のみ更新可能
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUserIdPatch: async (
      userId: string,
      user: User,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('usersUserIdPatch', 'userId', userId);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('usersUserIdPatch', 'user', user);
      const localVarPath = `/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} [department] 部署絞り込み。指定しなかった場合、すべての部署
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersGet(
      department?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(
        department,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersUserIdGet(
      userId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdGet(
        userId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザー情報の更新。管理者を除き、自分の情報のみ更新可能
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersUserIdPatch(
      userId: string,
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersUserIdPatch(userId, user, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @param {string} [department] 部署絞り込み。指定しなかった場合、すべての部署
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(department?: string, options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .usersGet(department, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUserIdGet(userId: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .usersUserIdGet(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザー情報の更新。管理者を除き、自分の情報のみ更新可能
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUserIdPatch(
      userId: string,
      user: User,
      options?: any,
    ): AxiosPromise<User> {
      return localVarFp
        .usersUserIdPatch(userId, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @param {string} [department] 部署絞り込み。指定しなかった場合、すべての部署
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersGet(department?: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersGet(department, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザー詳細の取得
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersUserIdGet(userId: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersUserIdGet(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザー情報の更新。管理者を除き、自分の情報のみ更新可能
   * @param {string} userId
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersUserIdPatch(
    userId: string,
    user: User,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .usersUserIdPatch(userId, user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserDiaryApi - axios parameter creator
 * @export
 */
export const UserDiaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersGet: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/diary/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdDiaryIdDelete: async (
      userId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdDelete', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdDelete', 'diaryId', diaryId);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdDiaryIdGet: async (
      userId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdGet', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdGet', 'diaryId', diaryId);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdDiaryIdPut: async (
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdPut', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdPut', 'diaryId', diaryId);
      // verify required parameter 'userDiary' is not null or undefined
      assertParamExists('diaryUsersUserIdDiaryIdPut', 'userDiary', userDiary);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdGet: async (
      userId: string,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('diaryUsersUserIdGet', 'userId', userId);
      const localVarPath = `/diary/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdPost: async (
      userId: string,
      createDiary: CreateDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('diaryUsersUserIdPost', 'userId', userId);
      // verify required parameter 'createDiary' is not null or undefined
      assertParamExists('diaryUsersUserIdPost', 'createDiary', createDiary);
      const localVarPath = `/diary/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserDiaryApi - functional programming interface
 * @export
 */
export const UserDiaryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserDiaryApiAxiosParamCreator(configuration);
  return {
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diaryUsersGet(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserDiary>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.diaryUsersGet(
        from,
        to,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diaryUsersUserIdDiaryIdDelete(
      userId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diaryUsersUserIdDiaryIdDelete(
          userId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diaryUsersUserIdDiaryIdGet(
      userId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diaryUsersUserIdDiaryIdGet(
          userId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diaryUsersUserIdDiaryIdPut(
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diaryUsersUserIdDiaryIdPut(
          userId,
          diaryId,
          userDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diaryUsersUserIdGet(
      userId: string,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diaryUsersUserIdGet(
          userId,
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async diaryUsersUserIdPost(
      userId: string,
      createDiary: CreateDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.diaryUsersUserIdPost(
          userId,
          createDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserDiaryApi - factory interface
 * @export
 */
export const UserDiaryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserDiaryApiFp(configuration);
  return {
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersGet(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<UserDiary>> {
      return localVarFp
        .diaryUsersGet(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdDiaryIdDelete(
      userId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .diaryUsersUserIdDiaryIdDelete(userId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdDiaryIdGet(
      userId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .diaryUsersUserIdDiaryIdGet(userId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdDiaryIdPut(
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .diaryUsersUserIdDiaryIdPut(userId, diaryId, userDiary, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdGet(
      userId: string,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<UserDiary>> {
      return localVarFp
        .diaryUsersUserIdGet(userId, from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateDiary} createDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    diaryUsersUserIdPost(
      userId: string,
      createDiary: CreateDiary,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .diaryUsersUserIdPost(userId, createDiary, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserDiaryApi - object-oriented interface
 * @export
 * @class UserDiaryApi
 * @extends {BaseAPI}
 */
export class UserDiaryApi extends BaseAPI {
  /**
   * 全員の日報一覧
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public diaryUsersGet(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .diaryUsersGet(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の削除
   * @param {string} userId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public diaryUsersUserIdDiaryIdDelete(
    userId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .diaryUsersUserIdDiaryIdDelete(userId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報詳細
   * @param {string} userId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public diaryUsersUserIdDiaryIdGet(
    userId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .diaryUsersUserIdDiaryIdGet(userId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の更新
   * @param {string} userId
   * @param {string} diaryId
   * @param {UserDiary} userDiary 日報の更新
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public diaryUsersUserIdDiaryIdPut(
    userId: string,
    diaryId: string,
    userDiary: UserDiary,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .diaryUsersUserIdDiaryIdPut(userId, diaryId, userDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの日報一覧
   * @param {string} userId
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public diaryUsersUserIdGet(
    userId: string,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .diaryUsersUserIdGet(userId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報を作成
   * @param {string} userId
   * @param {CreateDiary} createDiary 日報の作成
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public diaryUsersUserIdPost(
    userId: string,
    createDiary: CreateDiary,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .diaryUsersUserIdPost(userId, createDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
