/* tslint:disable */
/* eslint-disable */
/**
 * Tarako
 * タスク管理アプリケーションのバックエンドAPI
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Chat
 */
export interface Chat {
  /**
   * chat 履歴ID
   * @type {string}
   * @memberof Chat
   */
  chat_id: string;
  /**
   * ユーザーID
   * @type {string}
   * @memberof Chat
   */
  user_id: string;
  /**
   * チャットの日時
   * @type {string}
   * @memberof Chat
   */
  timestamp: string;
  /**
   * チャット内容
   * @type {string}
   * @memberof Chat
   */
  message: string;
  /**
   * ユーザーからのメッセージかどうか
   * @type {string}
   * @memberof Chat
   */
  from?: ChatFromEnum;
  /**
   * 作成日時
   * @type {string}
   * @memberof Chat
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof Chat
   */
  updated_at: string;
}

export const ChatFromEnum = {
  User: 'user',
  Bot: 'bot',
} as const;

export type ChatFromEnum = (typeof ChatFromEnum)[keyof typeof ChatFromEnum];

/**
 *
 * @export
 * @interface CreateSectionDiary
 */
export interface CreateSectionDiary {
  /**
   * 日報の日付
   * @type {string}
   * @memberof CreateSectionDiary
   */
  date?: string;
}
/**
 *
 * @export
 * @interface CreateUserDiary
 */
export interface CreateUserDiary {
  /**
   * 日報の日付
   * @type {string}
   * @memberof CreateUserDiary
   */
  date?: string;
  /**
   * 日報の詳細
   * @type {string}
   * @memberof CreateUserDiary
   */
  message?: string;
}
/**
 *
 * @export
 * @interface DiaryBase
 */
export interface DiaryBase {
  /**
   * 日報ID
   * @type {string}
   * @memberof DiaryBase
   */
  diary_id: string;
  /**
   * 課ID
   * @type {number}
   * @memberof DiaryBase
   */
  section_id: number;
  /**
   * 日報の日付
   * @type {string}
   * @memberof DiaryBase
   */
  date: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof DiaryBase
   */
  details: string;
  /**
   * AIからの分析
   * @type {string}
   * @memberof DiaryBase
   */
  ai_analysis: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof DiaryBase
   */
  serious: number;
  /**
   * 作成日時
   * @type {string}
   * @memberof DiaryBase
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof DiaryBase
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface PostTask201Response
 */
export interface PostTask201Response {
  /**
   *
   * @type {Task}
   * @memberof PostTask201Response
   */
  task?: Task;
  /**
   * タスクの作成を通知する
   * @type {string}
   * @memberof PostTask201Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface PostTask208Response
 */
export interface PostTask208Response {
  /**
   *
   * @type {Task}
   * @memberof PostTask208Response
   */
  originTask?: Task;
  /**
   *
   * @type {Task}
   * @memberof PostTask208Response
   */
  updatedTask?: Task;
  /**
   * 提案の理由
   * @type {string}
   * @memberof PostTask208Response
   */
  message?: string;
}
/**
 * 進捗状況
 * @export
 * @interface ProgressItem
 */
export interface ProgressItem {
  /**
   *
   * @type {string}
   * @memberof ProgressItem
   */
  datetime: string;
  /**
   * 進捗率
   * @type {number}
   * @memberof ProgressItem
   */
  percentage: number;
}
/**
 *
 * @export
 * @interface PutTaskEntryRequest
 */
export interface PutTaskEntryRequest {
  /**
   * ユーザーID
   * @type {string}
   * @memberof PutTaskEntryRequest
   */
  assigned_to?: string | null;
  /**
   * タスクID
   * @type {string}
   * @memberof PutTaskEntryRequest
   */
  task_id: string;
  /**
   * 課ID
   * @type {number}
   * @memberof PutTaskEntryRequest
   */
  section_id: number;
  /**
   * タスク名
   * @type {string}
   * @memberof PutTaskEntryRequest
   */
  title: string;
  /**
   *
   * @type {TaskCategory}
   * @memberof PutTaskEntryRequest
   */
  category: TaskCategory;
  /**
   * タスクのタグリスト
   * @type {Array<string>}
   * @memberof PutTaskEntryRequest
   */
  tags: Array<string>;
  /**
   * 進捗状況リスト
   * @type {Array<ProgressItem>}
   * @memberof PutTaskEntryRequest
   */
  progresses: Array<ProgressItem>;
  /**
   * タスクが完了したかどうか。progressesから自動的に判定される。検索の高速化のために存在
   * @type {boolean}
   * @memberof PutTaskEntryRequest
   */
  completed: boolean;
  /**
   * 深刻度
   * @type {number}
   * @memberof PutTaskEntryRequest
   */
  serious: number;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof PutTaskEntryRequest
   */
  details: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof PutTaskEntryRequest
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof PutTaskEntryRequest
   */
  updated_at: string;
}

/**
 *
 * @export
 * @interface RequestTask
 */
export interface RequestTask {
  /**
   * ユーザーID
   * @type {string}
   * @memberof RequestTask
   */
  user_id?: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof RequestTask
   */
  text?: string;
  /**
   * タスクID
   * @type {string}
   * @memberof RequestTask
   */
  reference_task_id?: string;
}
/**
 *
 * @export
 * @interface Section
 */
export interface Section {
  /**
   * 課ID
   * @type {number}
   * @memberof Section
   */
  section_id?: number;
  /**
   * 課名
   * @type {string}
   * @memberof Section
   */
  name: string;
  /**
   * 課のアイコン名
   * @type {string}
   * @memberof Section
   */
  icon: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof Section
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof Section
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface SectionDiary
 */
export interface SectionDiary {
  /**
   * 日報の作成に用いられたユーザーのIDリスト
   * @type {Array<string>}
   * @memberof SectionDiary
   */
  user_ids: Array<string>;
  /**
   * 日報ID
   * @type {string}
   * @memberof SectionDiary
   */
  diary_id: string;
  /**
   * 課ID
   * @type {number}
   * @memberof SectionDiary
   */
  section_id: number;
  /**
   * 日報の日付
   * @type {string}
   * @memberof SectionDiary
   */
  date: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof SectionDiary
   */
  details: string;
  /**
   * AIからの分析
   * @type {string}
   * @memberof SectionDiary
   */
  ai_analysis: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof SectionDiary
   */
  serious: number;
  /**
   * 作成日時
   * @type {string}
   * @memberof SectionDiary
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof SectionDiary
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * タスクID
   * @type {string}
   * @memberof Task
   */
  task_id: string;
  /**
   * ユーザーID
   * @type {string}
   * @memberof Task
   */
  assigned_to: string | null;
  /**
   * 課ID
   * @type {number}
   * @memberof Task
   */
  section_id: number;
  /**
   * タスク名
   * @type {string}
   * @memberof Task
   */
  title: string;
  /**
   *
   * @type {TaskCategory}
   * @memberof Task
   */
  category: TaskCategory;
  /**
   * タスクのタグリスト
   * @type {Array<string>}
   * @memberof Task
   */
  tags: Array<string>;
  /**
   * 進捗状況リスト
   * @type {Array<ProgressItem>}
   * @memberof Task
   */
  progresses: Array<ProgressItem>;
  /**
   * タスクが完了したかどうか。progressesから自動的に判定される。検索の高速化のために存在
   * @type {boolean}
   * @memberof Task
   */
  completed: boolean;
  /**
   * 深刻度
   * @type {number}
   * @memberof Task
   */
  serious: number;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof Task
   */
  details: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof Task
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof Task
   */
  updated_at: string;
}

/**
 * タスクのカテゴリー
 * @export
 * @enum {string}
 */

export const TaskCategory = {
  Hr: 'HR',
  Accounting: 'Accounting',
  GeneralAffairs: 'GeneralAffairs',
  Diary: 'Diary',
  Other: 'Other',
} as const;

export type TaskCategory = (typeof TaskCategory)[keyof typeof TaskCategory];

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  icon: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   * 課ID
   * @type {number}
   * @memberof User
   */
  section_id: number;
  /**
   * ユーザーID
   * @type {string}
   * @memberof User
   */
  user_id: string;
  /**
   * 作成日時
   * @type {string}
   * @memberof User
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof User
   */
  updated_at: string;
}
/**
 *
 * @export
 * @interface UserDiary
 */
export interface UserDiary {
  /**
   * ユーザーID
   * @type {string}
   * @memberof UserDiary
   */
  user_id: string;
  /**
   * 日報の作成に用いられたタスクのIDリスト
   * @type {Array<string>}
   * @memberof UserDiary
   */
  task_ids: Array<string>;
  /**
   * 日報ID
   * @type {string}
   * @memberof UserDiary
   */
  diary_id: string;
  /**
   * 課ID
   * @type {number}
   * @memberof UserDiary
   */
  section_id: number;
  /**
   * 日報の日付
   * @type {string}
   * @memberof UserDiary
   */
  date: string;
  /**
   * タスクの詳細
   * @type {string}
   * @memberof UserDiary
   */
  details: string;
  /**
   * AIからの分析
   * @type {string}
   * @memberof UserDiary
   */
  ai_analysis: string;
  /**
   * 深刻度の総計
   * @type {number}
   * @memberof UserDiary
   */
  serious: number;
  /**
   * 作成日時
   * @type {string}
   * @memberof UserDiary
   */
  created_at: string;
  /**
   * 更新日時
   * @type {string}
   * @memberof UserDiary
   */
  updated_at: string;
}

/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 全ユーザーのチャット一覧
     * @param {string} [from]
     * @param {string} [to]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllChatHistory: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/chat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] = from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザのチャット履歴一覧
     * @param {string} userId
     * @param {string} [from]
     * @param {string} [to]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUserChatHistory: async (
      userId: string,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getSingleUserChatHistory', 'userId', userId);
      const localVarPath = `/chat/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] = from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration);
  return {
    /**
     * 全ユーザーのチャット一覧
     * @param {string} [from]
     * @param {string} [to]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllChatHistory(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chat>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllChatHistory(from, to, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザのチャット履歴一覧
     * @param {string} userId
     * @param {string} [from]
     * @param {string} [to]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSingleUserChatHistory(
      userId: string,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chat>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSingleUserChatHistory(
          userId,
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ChatApiFp(configuration);
  return {
    /**
     * 全ユーザーのチャット一覧
     * @param {string} [from]
     * @param {string} [to]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllChatHistory(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<Chat>> {
      return localVarFp
        .getAllChatHistory(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザのチャット履歴一覧
     * @param {string} userId
     * @param {string} [from]
     * @param {string} [to]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUserChatHistory(
      userId: string,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<Chat>> {
      return localVarFp
        .getSingleUserChatHistory(userId, from, to, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
  /**
   * 全ユーザーのチャット一覧
   * @param {string} [from]
   * @param {string} [to]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatApi
   */
  public getAllChatHistory(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return ChatApiFp(this.configuration)
      .getAllChatHistory(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザのチャット履歴一覧
   * @param {string} userId
   * @param {string} [from]
   * @param {string} [to]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatApi
   */
  public getSingleUserChatHistory(
    userId: string,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return ChatApiFp(this.configuration)
      .getSingleUserChatHistory(userId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SectionApi - axios parameter creator
 * @export
 */
export const SectionApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 課の詳細
     * @param {number} sectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionEntry: async (
      sectionId: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('getSectionEntry', 'sectionId', sectionId);
      const localVarPath = `/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSections: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の作成
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionEntry: async (
      section: Section,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'section' is not null or undefined
      assertParamExists('postSectionEntry', 'section', section);
      const localVarPath = `/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        section,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の更新
     * @param {number} sectionId
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionEntry: async (
      sectionId: number,
      section: Section,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('putSectionEntry', 'sectionId', sectionId);
      // verify required parameter 'section' is not null or undefined
      assertParamExists('putSectionEntry', 'section', section);
      const localVarPath = `/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        section,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SectionApi - functional programming interface
 * @export
 */
export const SectionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SectionApiAxiosParamCreator(configuration);
  return {
    /**
     * 課の詳細
     * @param {number} sectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSectionEntry(
      sectionId: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionEntry(
        sectionId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSections(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Section>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSections(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の作成
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSectionEntry(
      section: Section,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postSectionEntry(section, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の更新
     * @param {number} sectionId
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putSectionEntry(
      sectionId: number,
      section: Section,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putSectionEntry(
        sectionId,
        section,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SectionApi - factory interface
 * @export
 */
export const SectionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SectionApiFp(configuration);
  return {
    /**
     * 課の詳細
     * @param {number} sectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionEntry(sectionId: number, options?: any): AxiosPromise<Section> {
      return localVarFp
        .getSectionEntry(sectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の一覧
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSections(options?: any): AxiosPromise<Array<Section>> {
      return localVarFp
        .getSections(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の作成
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionEntry(section: Section, options?: any): AxiosPromise<Section> {
      return localVarFp
        .postSectionEntry(section, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の更新
     * @param {number} sectionId
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionEntry(
      sectionId: number,
      section: Section,
      options?: any,
    ): AxiosPromise<Section> {
      return localVarFp
        .putSectionEntry(sectionId, section, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SectionApi - object-oriented interface
 * @export
 * @class SectionApi
 * @extends {BaseAPI}
 */
export class SectionApi extends BaseAPI {
  /**
   * 課の詳細
   * @param {number} sectionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public getSectionEntry(sectionId: number, options?: AxiosRequestConfig) {
    return SectionApiFp(this.configuration)
      .getSectionEntry(sectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の一覧
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public getSections(options?: AxiosRequestConfig) {
    return SectionApiFp(this.configuration)
      .getSections(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の作成
   * @param {Section} section
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public postSectionEntry(section: Section, options?: AxiosRequestConfig) {
    return SectionApiFp(this.configuration)
      .postSectionEntry(section, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の更新
   * @param {number} sectionId
   * @param {Section} section
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionApi
   */
  public putSectionEntry(
    sectionId: number,
    section: Section,
    options?: AxiosRequestConfig,
  ) {
    return SectionApiFp(this.configuration)
      .putSectionEntry(sectionId, section, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SectionDiaryApi - axios parameter creator
 * @export
 */
export const SectionDiaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 日報の削除
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSectionDiaryEntry: async (
      sectionId: number,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('deleteSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('deleteSectionDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSectionsDiaries: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/diary/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課の日報一覧
     * @param {number} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaries: async (
      sectionId: number,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('getSectionDiaries', 'sectionId', sectionId);
      const localVarPath = `/diary/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報詳細
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaryEntry: async (
      sectionId: number,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('getSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('getSectionDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {number} sectionId
     * @param {CreateSectionDiary} createSectionDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionDiaryEntry: async (
      sectionId: number,
      createSectionDiary: CreateSectionDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('postSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'createSectionDiary' is not null or undefined
      assertParamExists(
        'postSectionDiaryEntry',
        'createSectionDiary',
        createSectionDiary,
      );
      const localVarPath = `/diary/sections/{section_id}`.replace(
        `{${'section_id'}}`,
        encodeURIComponent(String(sectionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSectionDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の更新
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionDiaryEntry: async (
      sectionId: number,
      diaryId: string,
      sectionDiary: SectionDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('putSectionDiaryEntry', 'sectionId', sectionId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('putSectionDiaryEntry', 'diaryId', diaryId);
      // verify required parameter 'sectionDiary' is not null or undefined
      assertParamExists('putSectionDiaryEntry', 'sectionDiary', sectionDiary);
      const localVarPath = `/diary/sections/{section_id}/{diary_id}`
        .replace(`{${'section_id'}}`, encodeURIComponent(String(sectionId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sectionDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SectionDiaryApi - functional programming interface
 * @export
 */
export const SectionDiaryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SectionDiaryApiAxiosParamCreator(configuration);
  return {
    /**
     * 日報の削除
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSectionDiaryEntry(
          sectionId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllSectionsDiaries(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SectionDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllSectionsDiaries(
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課の日報一覧
     * @param {number} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSectionDiaries(
      sectionId: number,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SectionDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSectionDiaries(
          sectionId,
          from,
          to,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報詳細
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSectionDiaryEntry(
          sectionId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {number} sectionId
     * @param {CreateSectionDiary} createSectionDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSectionDiaryEntry(
      sectionId: number,
      createSectionDiary: CreateSectionDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postSectionDiaryEntry(
          sectionId,
          createSectionDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の更新
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      sectionDiary: SectionDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putSectionDiaryEntry(
          sectionId,
          diaryId,
          sectionDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SectionDiaryApi - factory interface
 * @export
 */
export const SectionDiaryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SectionDiaryApiFp(configuration);
  return {
    /**
     * 日報の削除
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSectionDiaryEntry(sectionId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 全課の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSectionsDiaries(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<SectionDiary>> {
      return localVarFp
        .getAllSectionsDiaries(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課の日報一覧
     * @param {number} sectionId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaries(
      sectionId: number,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<SectionDiary>> {
      return localVarFp
        .getSectionDiaries(sectionId, from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報詳細
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .getSectionDiaryEntry(sectionId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 課に所属しているユーザーの日報から、課の日報を作成
     * @param {number} sectionId
     * @param {CreateSectionDiary} createSectionDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSectionDiaryEntry(
      sectionId: number,
      createSectionDiary: CreateSectionDiary,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .postSectionDiaryEntry(sectionId, createSectionDiary, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の更新
     * @param {number} sectionId
     * @param {string} diaryId
     * @param {SectionDiary} sectionDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSectionDiaryEntry(
      sectionId: number,
      diaryId: string,
      sectionDiary: SectionDiary,
      options?: any,
    ): AxiosPromise<SectionDiary> {
      return localVarFp
        .putSectionDiaryEntry(sectionId, diaryId, sectionDiary, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SectionDiaryApi - object-oriented interface
 * @export
 * @class SectionDiaryApi
 * @extends {BaseAPI}
 */
export class SectionDiaryApi extends BaseAPI {
  /**
   * 日報の削除
   * @param {number} sectionId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public deleteSectionDiaryEntry(
    sectionId: number,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .deleteSectionDiaryEntry(sectionId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 全課の日報一覧
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public getAllSectionsDiaries(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .getAllSectionsDiaries(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課の日報一覧
   * @param {number} sectionId
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public getSectionDiaries(
    sectionId: number,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .getSectionDiaries(sectionId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報詳細
   * @param {number} sectionId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public getSectionDiaryEntry(
    sectionId: number,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .getSectionDiaryEntry(sectionId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 課に所属しているユーザーの日報から、課の日報を作成
   * @param {number} sectionId
   * @param {CreateSectionDiary} createSectionDiary 日報の作成
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public postSectionDiaryEntry(
    sectionId: number,
    createSectionDiary: CreateSectionDiary,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .postSectionDiaryEntry(sectionId, createSectionDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の更新
   * @param {number} sectionId
   * @param {string} diaryId
   * @param {SectionDiary} sectionDiary 日報の更新
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionDiaryApi
   */
  public putSectionDiaryEntry(
    sectionId: number,
    diaryId: string,
    sectionDiary: SectionDiary,
    options?: AxiosRequestConfig,
  ) {
    return SectionDiaryApiFp(this.configuration)
      .putSectionDiaryEntry(sectionId, diaryId, sectionDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskEntry: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('deleteTaskEntry', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskEntry: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskEntry', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
     * @param {string} [fromStartDatetime] タスクの開始期間の前方の絞り込み。指定しなかった場合、制限なし
     * @param {string} [toStartDatetime] タスクの開始期間の後方の絞り込み。指定しなかった場合、制限なし
     * @param {string} [fromLastStatus] タスクの最新更新時間の前方の絞り込み。指定しなかった場合、制限なし。*_start_datetimeが指定されている場合、無視される
     * @param {string} [toLastStatus] タスクの最新更新時間の後方の絞り込み。指定しなかった場合、制限なし*_start_datetimeが指定されている場合、無視される
     * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks: async (
      notAssigned?: boolean,
      userId?: Array<string>,
      fromStartDatetime?: string,
      toStartDatetime?: string,
      fromLastStatus?: string,
      toLastStatus?: string,
      status?: GetTasksStatusEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (notAssigned !== undefined) {
        localVarQueryParameter['not_assigned'] = notAssigned;
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (fromStartDatetime !== undefined) {
        localVarQueryParameter['from_start_datetime'] = fromStartDatetime;
      }

      if (toStartDatetime !== undefined) {
        localVarQueryParameter['to_start_datetime'] = toStartDatetime;
      }

      if (fromLastStatus !== undefined) {
        localVarQueryParameter['from_last_status'] = fromLastStatus;
      }

      if (toLastStatus !== undefined) {
        localVarQueryParameter['to_last_status'] = toLastStatus;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクの投稿
     * @param {RequestTask} requestTask
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTask: async (
      requestTask: RequestTask,
      forceCreate?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestTask' is not null or undefined
      assertParamExists('postTask', 'requestTask', requestTask);
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (forceCreate !== undefined) {
        localVarQueryParameter['force_create'] = forceCreate;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestTask,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {PutTaskEntryRequest} putTaskEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTaskEntry: async (
      taskId: string,
      putTaskEntryRequest: PutTaskEntryRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('putTaskEntry', 'taskId', taskId);
      // verify required parameter 'putTaskEntryRequest' is not null or undefined
      assertParamExists(
        'putTaskEntry',
        'putTaskEntryRequest',
        putTaskEntryRequest,
      );
      const localVarPath = `/tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        putTaskEntryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration);
  return {
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTaskEntry(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskEntry(
        taskId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskEntry(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskEntry(
        taskId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
     * @param {string} [fromStartDatetime] タスクの開始期間の前方の絞り込み。指定しなかった場合、制限なし
     * @param {string} [toStartDatetime] タスクの開始期間の後方の絞り込み。指定しなかった場合、制限なし
     * @param {string} [fromLastStatus] タスクの最新更新時間の前方の絞り込み。指定しなかった場合、制限なし。*_start_datetimeが指定されている場合、無視される
     * @param {string} [toLastStatus] タスクの最新更新時間の後方の絞り込み。指定しなかった場合、制限なし*_start_datetimeが指定されている場合、無視される
     * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasks(
      notAssigned?: boolean,
      userId?: Array<string>,
      fromStartDatetime?: string,
      toStartDatetime?: string,
      fromLastStatus?: string,
      toLastStatus?: string,
      status?: GetTasksStatusEnum,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(
        notAssigned,
        userId,
        fromStartDatetime,
        toStartDatetime,
        fromLastStatus,
        toLastStatus,
        status,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクの投稿
     * @param {RequestTask} requestTask
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTask(
      requestTask: RequestTask,
      forceCreate?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PostTask201Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postTask(
        requestTask,
        forceCreate,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {PutTaskEntryRequest} putTaskEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putTaskEntry(
      taskId: string,
      putTaskEntryRequest: PutTaskEntryRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskEntry(
        taskId,
        putTaskEntryRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TaskApiFp(configuration);
  return {
    /**
     * タスクの削除
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskEntry(taskId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteTaskEntry(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスク詳細の取得
     * @param {string} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskEntry(taskId: string, options?: any): AxiosPromise<Task> {
      return localVarFp
        .getTaskEntry(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
     * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
     * @param {string} [fromStartDatetime] タスクの開始期間の前方の絞り込み。指定しなかった場合、制限なし
     * @param {string} [toStartDatetime] タスクの開始期間の後方の絞り込み。指定しなかった場合、制限なし
     * @param {string} [fromLastStatus] タスクの最新更新時間の前方の絞り込み。指定しなかった場合、制限なし。*_start_datetimeが指定されている場合、無視される
     * @param {string} [toLastStatus] タスクの最新更新時間の後方の絞り込み。指定しなかった場合、制限なし*_start_datetimeが指定されている場合、無視される
     * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks(
      notAssigned?: boolean,
      userId?: Array<string>,
      fromStartDatetime?: string,
      toStartDatetime?: string,
      fromLastStatus?: string,
      toLastStatus?: string,
      status?: GetTasksStatusEnum,
      options?: any,
    ): AxiosPromise<Array<Task>> {
      return localVarFp
        .getTasks(
          notAssigned,
          userId,
          fromStartDatetime,
          toStartDatetime,
          fromLastStatus,
          toLastStatus,
          status,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクの投稿
     * @param {RequestTask} requestTask
     * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTask(
      requestTask: RequestTask,
      forceCreate?: boolean,
      options?: any,
    ): AxiosPromise<PostTask201Response> {
      return localVarFp
        .postTask(requestTask, forceCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * タスクを更新する。
     * @param {string} taskId
     * @param {PutTaskEntryRequest} putTaskEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTaskEntry(
      taskId: string,
      putTaskEntryRequest: PutTaskEntryRequest,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .putTaskEntry(taskId, putTaskEntryRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
  /**
   * タスクの削除
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public deleteTaskEntry(taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .deleteTaskEntry(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスク詳細の取得
   * @param {string} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTaskEntry(taskId: string, options?: AxiosRequestConfig) {
    return TaskApiFp(this.configuration)
      .getTaskEntry(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {boolean} [notAssigned] 担当者がいないタスクを絞り込む。user_id_queryよりも優先される
   * @param {Array<string>} [userId] ユーザー絞り込み。note_assignedがtrueの場合、無視される。複数のユーザーを指定可能
   * @param {string} [fromStartDatetime] タスクの開始期間の前方の絞り込み。指定しなかった場合、制限なし
   * @param {string} [toStartDatetime] タスクの開始期間の後方の絞り込み。指定しなかった場合、制限なし
   * @param {string} [fromLastStatus] タスクの最新更新時間の前方の絞り込み。指定しなかった場合、制限なし。*_start_datetimeが指定されている場合、無視される
   * @param {string} [toLastStatus] タスクの最新更新時間の後方の絞り込み。指定しなかった場合、制限なし*_start_datetimeが指定されている場合、無視される
   * @param {GetTasksStatusEnum} [status] 進行中か否かで絞り込み。指定しなかった場合、現状での絞り込みを行わない
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public getTasks(
    notAssigned?: boolean,
    userId?: Array<string>,
    fromStartDatetime?: string,
    toStartDatetime?: string,
    fromLastStatus?: string,
    toLastStatus?: string,
    status?: GetTasksStatusEnum,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .getTasks(
        notAssigned,
        userId,
        fromStartDatetime,
        toStartDatetime,
        fromLastStatus,
        toLastStatus,
        status,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクの投稿
   * @param {RequestTask} requestTask
   * @param {boolean} [forceCreate] すでに存在するタスクを強制的に作成するかどうか。指定しなかった場合、変更を提案されることがある。
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public postTask(
    requestTask: RequestTask,
    forceCreate?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .postTask(requestTask, forceCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * タスクを更新する。
   * @param {string} taskId
   * @param {PutTaskEntryRequest} putTaskEntryRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskApi
   */
  public putTaskEntry(
    taskId: string,
    putTaskEntryRequest: PutTaskEntryRequest,
    options?: AxiosRequestConfig,
  ) {
    return TaskApiFp(this.configuration)
      .putTaskEntry(taskId, putTaskEntryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetTasksStatusEnum = {
  InProgress: 'in_progress',
  Completed: 'completed',
} as const;
export type GetTasksStatusEnum =
  (typeof GetTasksStatusEnum)[keyof typeof GetTasksStatusEnum];

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserEntry: async (
      userId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserEntry', 'userId', userId);
      const localVarPath = `/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [sectionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      sectionId?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sectionId !== undefined) {
        localVarQueryParameter['section_id'] = sectionId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの作成
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEntry: async (
      user: User,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      assertParamExists('postUserEntry', 'user', user);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの更新
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserEntry: async (
      userId: string,
      user: User,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('putUserEntry', 'userId', userId);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('putUserEntry', 'user', user);
      const localVarPath = `/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserEntry(
      userId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEntry(
        userId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {number} [sectionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      sectionId?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        sectionId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの作成
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserEntry(
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postUserEntry(
        user,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの更新
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserEntry(
      userId: string,
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putUserEntry(
        userId,
        user,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * ユーザー詳細の取得
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserEntry(userId: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserEntry(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} [sectionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(sectionId?: number, options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(sectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの作成
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEntry(user: User, options?: any): AxiosPromise<User> {
      return localVarFp
        .postUserEntry(user, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの更新
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserEntry(
      userId: string,
      user: User,
      options?: any,
    ): AxiosPromise<User> {
      return localVarFp
        .putUserEntry(userId, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * ユーザー詳細の取得
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserEntry(userId: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserEntry(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [sectionId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUsers(sectionId?: number, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUsers(sectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの作成
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public postUserEntry(user: User, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .postUserEntry(user, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの更新
   * @param {string} userId
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public putUserEntry(
    userId: string,
    user: User,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .putUserEntry(userId, user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserDiaryApi - axios parameter creator
 * @export
 */
export const UserDiaryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserDiaryEntry: async (
      userId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('deleteUserDiaryEntry', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('deleteUserDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersDiaries: async (
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/diary/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaries: async (
      userId: string,
      from?: string,
      to?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserDiaries', 'userId', userId);
      const localVarPath = `/diary/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] =
          (from as any) instanceof Date
            ? (from as any).toISOString().substring(0, 10)
            : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] =
          (to as any) instanceof Date
            ? (to as any).toISOString().substring(0, 10)
            : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaryEntry: async (
      userId: string,
      diaryId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserDiaryEntry', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('getUserDiaryEntry', 'diaryId', diaryId);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateUserDiary} createUserDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDiaryEntry: async (
      userId: string,
      createUserDiary: CreateUserDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('postUserDiaryEntry', 'userId', userId);
      // verify required parameter 'createUserDiary' is not null or undefined
      assertParamExists(
        'postUserDiaryEntry',
        'createUserDiary',
        createUserDiary,
      );
      const localVarPath = `/diary/users/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserDiaryEntry: async (
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('putUserDiaryEntry', 'userId', userId);
      // verify required parameter 'diaryId' is not null or undefined
      assertParamExists('putUserDiaryEntry', 'diaryId', diaryId);
      // verify required parameter 'userDiary' is not null or undefined
      assertParamExists('putUserDiaryEntry', 'userDiary', userDiary);
      const localVarPath = `/diary/users/{user_id}/{diary_id}`
        .replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'diary_id'}}`, encodeURIComponent(String(diaryId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDiary,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserDiaryApi - functional programming interface
 * @export
 */
export const UserDiaryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserDiaryApiAxiosParamCreator(configuration);
  return {
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserDiaryEntry(
          userId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUsersDiaries(
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserDiary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllUsersDiaries(from, to, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserDiaries(
      userId: string,
      from?: string,
      to?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserDiary>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDiaries(
        userId,
        from,
        to,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserDiaryEntry(
          userId,
          diaryId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateUserDiary} createUserDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserDiaryEntry(
      userId: string,
      createUserDiary: CreateUserDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUserDiaryEntry(
          userId,
          createUserDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserDiaryEntry(
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putUserDiaryEntry(
          userId,
          diaryId,
          userDiary,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserDiaryApi - factory interface
 * @export
 */
export const UserDiaryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserDiaryApiFp(configuration);
  return {
    /**
     * 日報の削除
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserDiaryEntry(userId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 全員の日報一覧
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersDiaries(
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<UserDiary>> {
      return localVarFp
        .getAllUsersDiaries(from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ユーザーの日報一覧
     * @param {string} userId
     * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
     * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaries(
      userId: string,
      from?: string,
      to?: string,
      options?: any,
    ): AxiosPromise<Array<UserDiary>> {
      return localVarFp
        .getUserDiaries(userId, from, to, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報詳細
     * @param {string} userId
     * @param {string} diaryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDiaryEntry(
      userId: string,
      diaryId: string,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .getUserDiaryEntry(userId, diaryId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報を作成
     * @param {string} userId
     * @param {CreateUserDiary} createUserDiary 日報の作成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDiaryEntry(
      userId: string,
      createUserDiary: CreateUserDiary,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .postUserDiaryEntry(userId, createUserDiary, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 日報の更新
     * @param {string} userId
     * @param {string} diaryId
     * @param {UserDiary} userDiary 日報の更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserDiaryEntry(
      userId: string,
      diaryId: string,
      userDiary: UserDiary,
      options?: any,
    ): AxiosPromise<UserDiary> {
      return localVarFp
        .putUserDiaryEntry(userId, diaryId, userDiary, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserDiaryApi - object-oriented interface
 * @export
 * @class UserDiaryApi
 * @extends {BaseAPI}
 */
export class UserDiaryApi extends BaseAPI {
  /**
   * 日報の削除
   * @param {string} userId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public deleteUserDiaryEntry(
    userId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .deleteUserDiaryEntry(userId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 全員の日報一覧
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public getAllUsersDiaries(
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .getAllUsersDiaries(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザーの日報一覧
   * @param {string} userId
   * @param {string} [from] 開始日で絞り込み。指定しなかった場合、制限なし
   * @param {string} [to] 終了日で絞り込み。指定しなかった場合、制限なし
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public getUserDiaries(
    userId: string,
    from?: string,
    to?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .getUserDiaries(userId, from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報詳細
   * @param {string} userId
   * @param {string} diaryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public getUserDiaryEntry(
    userId: string,
    diaryId: string,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .getUserDiaryEntry(userId, diaryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報を作成
   * @param {string} userId
   * @param {CreateUserDiary} createUserDiary 日報の作成
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public postUserDiaryEntry(
    userId: string,
    createUserDiary: CreateUserDiary,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .postUserDiaryEntry(userId, createUserDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 日報の更新
   * @param {string} userId
   * @param {string} diaryId
   * @param {UserDiary} userDiary 日報の更新
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserDiaryApi
   */
  public putUserDiaryEntry(
    userId: string,
    diaryId: string,
    userDiary: UserDiary,
    options?: AxiosRequestConfig,
  ) {
    return UserDiaryApiFp(this.configuration)
      .putUserDiaryEntry(userId, diaryId, userDiary, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
